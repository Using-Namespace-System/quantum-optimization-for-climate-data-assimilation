\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{xcolor}

\lstset{
    backgroundcolor=\color{lightgray},
    basicstyle=\ttfamily,
    breaklines=true
}

\title{quantum optimization for climate data assimilation}
\author{Brian Recktenwall-Calvet}
\date{October 2024}
\begin{document}

\maketitle

\section{Introduction}

4DVAR (Four-Dimensional Variational Data Assimilation), 


\section{4DVAR Cost Function Python}
\begin{lstlisting}[language=Python]
import numpy as np
from scipy.optimize import minimize

def cost_function(x, x_b, y_obs, B_inv, R_inv, H):
    """
    4DVAR cost function using observation data.
    
    :param x: The analysis state (concatenated over all time steps)
    :param x_b: The background state (concatenated over all time steps)
    :param y_obs: observations (concatenated over all time steps)
    :param B_inv: Inverse of the background error covariance matrix (block-diagonal for all time steps)
    :param R_inv: Inverse of the observation error covariance matrix (block-diagonal for all time steps)
    :param H: Observation operator (block-diagonal for all time steps)
    :return: Cost (scalar)
    """
    background_term = 0.5 * np.dot((x - x_b).T, np.dot(B_inv, (x - x_b)))
    observation_term = 0.5 * np.dot((y_obs - np.dot(H, x)).T, np.dot(R_inv, (y_obs - np.dot(H, x))))
    return background_term + observation_term

# Flatten RAP temperature forecast and observations for operation
x_b_flat = temperature_obs.values.flatten()  # Background state (RAP forecast)
y_obs_flat = obs_on_grid.flatten()  # observations (interpolated to grid)
x0 = x_b_flat  # Initial guess for the analysis state

# Inverse covariance matrices (identity matrices for simplicity)
B_inv = np.eye(x_b_flat.size)  # Inverse of background error covariance
R_inv = np.eye(y_obs_flat.size)  # Inverse of observation error covariance

# Observation operator (identity matrix for simplicity)
H = np.eye(x_b_flat.size)

# Minimize the cost function to obtain the analysis state
result = minimize(cost_function, x0, args=(x_b_flat, y_obs_flat, B_inv, R_inv, H), method='L-BFGS-B')

# Retrieve the optimal analysis state (the 4DVAR result)
optimal_analysis = result.x.reshape(temperature_obs.shape)

\end{lstlisting}


\end{document}

